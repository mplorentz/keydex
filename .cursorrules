# Keydex Cursor Rules

## Service and Repository Architecture

### When to Use Repositories
Create a **Repository** class when data access meets ANY of these criteria:
- Complex caching logic (in-memory + persistence)
- Stream management for reactive updates
- Multiple specialized queries (e.g., by ID, by status, filtered lists)
- Multiple services need the same data access
- Might swap storage implementations (SharedPreferences → SQLite)
- Would be 100+ lines of data access code

**Example: LockboxRepository**
```dart
final lockboxRepositoryProvider = Provider<LockboxRepository>((ref) {
  final repository = LockboxRepository();
  ref.onDispose(() => repository.dispose());
  return repository;
});

class LockboxRepository {
  final StreamController<List<Lockbox>> _controller = StreamController.broadcast();
  List<Lockbox>? _cache;
  
  Stream<List<Lockbox>> get stream => _controller.stream;
  Future<List<Lockbox>> getAll() async { /* load + cache */ }
  Future<Lockbox?> getById(String id) async { /* query cache */ }
  Future<void> save(Lockbox lockbox) async { /* persist + notify */ }
}
```

### When to Use Services Only
Use **Service-only** architecture (no repository) when:
- Simple CRUD operations (read/write SharedPreferences)
- Only one service needs this data
- Minimal or no caching logic
- No complex stream management
- Under 100 lines of data access

**Example: Service-Only Pattern**
```dart
final myServiceProvider = Provider<MyService>((ref) {
  return MyService(ref.read(otherServiceProvider));
});

class MyService {
  final OtherService _otherService;
  MyService(this._otherService);
  
  Future<void> doSomething() async {
    final prefs = await SharedPreferences.getInstance();
    // Simple data access inline
  }
}
```

### Service Pattern (Business Logic)
All services MUST:
- Be instance classes (not static)
- Use dependency injection via Riverpod
- Have a corresponding Provider
- Accept dependencies via constructor

**Example: Service with Dependencies**
```dart
final myServiceProvider = Provider<MyService>((ref) {
  return MyService(
    ref.read(repositoryProvider),
    ref.read(otherServiceProvider),
  );
});

class MyService {
  final MyRepository _repository;
  final OtherService _otherService;
  
  MyService(this._repository, this._otherService);
  
  Future<Result> doBusinessLogic() async {
    // Validation, orchestration, business rules
    final data = await _repository.getData();
    return _otherService.process(data);
  }
}
```

### Breaking Circular Dependencies
When services depend on each other, add explicit types:

```dart
// Both providers need explicit types to break inference cycle
final Provider<ServiceA> serviceAProvider = Provider<ServiceA>((ref) {
  final ServiceB serviceB = ref.read(serviceBProvider);
  return ServiceA(serviceB);
});

final Provider<ServiceB> serviceBProvider = Provider<ServiceB>((ref) {
  final ServiceA serviceA = ref.read(serviceAProvider);
  return ServiceB(serviceA);
});
```

### Don't Create Thin Wrappers
❌ **Bad: Thin repository that just delegates**
```dart
class KeyRepository {
  final Ref _ref;
  Future<String?> getKey() => KeyService.getKey();
  Future<void> clearKey() {
    await KeyService.clearKey();
    _ref.invalidate(keyProvider);
  }
}
```

✅ **Good: Use service directly with providers**
```dart
final keyServiceProvider = Provider<KeyService>((ref) => KeyService());

final currentKeyProvider = FutureProvider<String?>((ref) async {
  final keyService = ref.watch(keyServiceProvider);
  return await keyService.getCurrentKey();
});
```

## Nostr Key Format Conventions

### Hex Format (Internal)
- **Use hex format (64 characters, no 0x prefix) for:**
  - All internal data storage and processing
  - Service-to-service communication
  - Database storage
  - API payloads
  - Cryptographic operations
  - Model fields (e.g., `KeyHolder.pubkey`, `ShardEvent.recipientPubkey`)

### Bech32 Format (UI/Display)
- **Use bech32 format (npub1..., nsec1...) for:**
  - User interface display
  - User input fields
  - Logging for human readability
  - Error messages shown to users
  - Configuration files that users edit

## Nostr Event Payload Conventions

### Snake Case for Raw Nostr Events
- **Always use snake_case (not camelCase) for JSON payloads in raw Nostr events**
  - NDK automatically converts snake_case to camelCase when processing events
  - This ensures consistency across the Nostr protocol
  - Examples: `lockbox_id`, `shard_index`, `invite_code`, `confirmed_at`

**Example:**
```dart
// ✅ Good: Use snake_case in Nostr event payloads
final confirmationData = {
  'type': 'shard_confirmation',
  'lockbox_id': lockboxId,
  'shard_index': shardIndex,
  'key_holder_pubkey': currentPubkey,
  'confirmed_at': DateTime.now().toIso8601String(),
};

// ❌ Bad: Don't use camelCase in Nostr event payloads
final confirmationData = {
  'lockboxId': lockboxId,  // Wrong - NDK expects snake_case
  'shardIndex': shardIndex,
};
```

## Nostr Event Expiration

### NIP-40 Expiration Tags
- **All Nostr events published by Keydex MUST include NIP-40 expiration tags**
- Expiration is set to 7 days from publication time
- Expiration tags are automatically added by `publishEncryptedEvent` and `publishEncryptedEventToMultiple`
- Format: `['expiration', '<unix_timestamp_in_seconds>']` per NIP-40 specification
- The expiration tag is added to the rumor event (inner event), not the gift wrap (outer event)
- See NIP-40 for full specification details

**Note:** When publishing events, you do NOT need to manually add expiration tags. They are automatically included by the publishing functions.

## UI Design and Theming

### Design Guide
**IMPORTANT**: When working on UI components, screens, or styling, ALWAYS reference `DESIGN_GUIDE.md` for:
- Color palette and usage rules
- Typography system
- Component patterns
- Layout guidelines
- Visual style principles

### When to Reference DESIGN_GUIDE.md
Read the design guide when:
- Creating new screens or pages
- Building new widgets or components
- Styling existing components
- Adding buttons or actions
- Working with forms or lists
- Choosing colors or fonts
- Implementing layouts
- Making any visual design decisions

### The Monochrome Rule (Most Important!)
**Keydex3 uses ONLY grayscale colors** - no accent colors beyond error red
- All UI elements use shades of gray
- Buttons use medium grays (light: `#808080`, dark: `#404040`)
- RowButtonStack creates monotonic gray gradients (no visual "dips")
- High contrast between text and background in both light and dark modes
- Never add colorful UI elements - stay monochrome

### Active Theme
The app uses the **keydex3 theme** defined in `lib/widgets/theme.dart`
- Stark black and white monochrome palette
- System theme support (light and dark modes)
- Minimal rounding (4pt for fields, 12pt for buttons)
- Flat design with subtle shadows (2pt elevation on buttons)
- Confident typography (Archivo for titles, Fira Sans for body)
- Razor-thin dividers (0.5pt) between list items

### Quick Design References
- **Primary Action**: Use `RowButton` widget (outlined with gray fill, full-width, at bottom)
- **Multiple Actions**: Use `RowButtonStack` widget (monotonic gray gradient, darker at bottom)
- **Forms**: Match scaffold background, subtle borders, filled inputs
- **Lists**: Use `ListView.separated` with dividers, icon containers use `surfaceContainer`
- **AppBar**: Large (40pt), left-aligned, 100pt toolbar height, transparent surface tint
- **Icons**: Use `onSurface` color for high contrast

**Remember**: Check DESIGN_GUIDE.md for complete details before implementing any UI changes.
- If you need to manually verify some behavior in the UI you can run the app for web and use Playwright MCP to interact with it. Use the task "Flutter: Build and Serve for Playwright" to start.

## Pull Request Requirements

### Pre-PR Checklist
Before opening a pull request, you MUST verify ALL of the following requirements:

#### 1. Tests Pass
- **Run all tests**: `flutter test`
- All tests must pass with 0 failures
- No skipped tests unless explicitly documented why they're skipped
- Test coverage should not decrease for modified code

#### 2. Golden Tests Updated
- If UI changes were made, regenerate golden test files
- **Update goldens**: `flutter test --update-goldens`
- Review the updated golden images to ensure they match expectations
- Commit the updated golden files with your changes
- Re-run tests after updating to ensure they pass: `flutter test`

#### 3. No Analyzer Errors
- **Run analyzer**: `flutter analyze`
- Output must show: "No issues found!"
- Zero errors, zero warnings, zero hints
- Do not suppress analyzer warnings with `// ignore:` comments unless absolutely necessary and documented

#### 4. Code Formatting
- **Format code**: `dart format .`
- All code must follow Dart formatting standards
- No manual formatting that violates `dart format` rules

#### 5. Linter Compliance
- All linter rules in `analysis_options.yaml` must be followed
- Fix any linter warnings or errors
- Do not disable linter rules without team discussion

### Running the Complete Pre-PR Check
Run these commands in sequence to verify all requirements:

```bash
# 1. Format code
dart format .

# 2. Run analyzer
flutter analyze

# 3. Update golden tests (if UI changes were made)
flutter test --update-goldens

# 4. Run all tests
flutter test

# 5. Verify no issues
flutter analyze
```

All commands must complete successfully before opening a PR.

### AI Assistant PR Workflow
When preparing code for a PR, AI assistants should:

1. **After making changes**: Automatically run `flutter analyze` to check for issues
2. **Fix any analyzer errors** before declaring the task complete
3. **Run tests** to verify changes don't break existing functionality
4. **Update golden tests** if UI components were modified
5. **Format code** using `dart format .`
6. **Inform the user** if any tests fail or analyzer errors remain
7. **Do not open/push PRs** with known failing tests or analyzer errors

### Common Pre-PR Issues

#### Golden Test Failures
If golden tests fail after changes:
```bash
# Review the failures
flutter test

# If changes are intentional, update goldens
flutter test --update-goldens

# Verify tests now pass
flutter test
```

#### Analyzer Errors After Refactoring
- Unused imports: Remove them
- Missing `const` constructors: Add `const` where appropriate
- Type errors: Ensure types are correct throughout the call chain
- Null safety issues: Handle nullability properly

#### Test Failures
- Review test output carefully
- Update test expectations if behavior intentionally changed
- Fix bugs if tests reveal issues in the implementation
- Do not skip failing tests to make CI pass

### PR Description Guidelines
When opening a PR, include:
- **What**: Brief description of changes
- **Why**: Reason for the changes
- **Testing**: How the changes were tested
- **Screenshots**: For UI changes (before/after if applicable)
- **Breaking Changes**: Document any breaking API changes