# Keydex Cursor Rules

## Service and Repository Architecture

### When to Use Repositories
Create a **Repository** class when data access meets ANY of these criteria:
- Complex caching logic (in-memory + persistence)
- Stream management for reactive updates
- Multiple specialized queries (e.g., by ID, by status, filtered lists)
- Multiple services need the same data access
- Might swap storage implementations (SharedPreferences → SQLite)
- Would be 100+ lines of data access code

**Example: LockboxRepository**
```dart
final lockboxRepositoryProvider = Provider<LockboxRepository>((ref) {
  final repository = LockboxRepository();
  ref.onDispose(() => repository.dispose());
  return repository;
});

class LockboxRepository {
  final StreamController<List<Lockbox>> _controller = StreamController.broadcast();
  List<Lockbox>? _cache;
  
  Stream<List<Lockbox>> get stream => _controller.stream;
  Future<List<Lockbox>> getAll() async { /* load + cache */ }
  Future<Lockbox?> getById(String id) async { /* query cache */ }
  Future<void> save(Lockbox lockbox) async { /* persist + notify */ }
}
```

### When to Use Services Only
Use **Service-only** architecture (no repository) when:
- Simple CRUD operations (read/write SharedPreferences)
- Only one service needs this data
- Minimal or no caching logic
- No complex stream management
- Under 100 lines of data access

**Example: Service-Only Pattern**
```dart
final myServiceProvider = Provider<MyService>((ref) {
  return MyService(ref.read(otherServiceProvider));
});

class MyService {
  final OtherService _otherService;
  MyService(this._otherService);
  
  Future<void> doSomething() async {
    final prefs = await SharedPreferences.getInstance();
    // Simple data access inline
  }
}
```

### Service Pattern (Business Logic)
All services MUST:
- Be instance classes (not static)
- Use dependency injection via Riverpod
- Have a corresponding Provider
- Accept dependencies via constructor

**Example: Service with Dependencies**
```dart
final myServiceProvider = Provider<MyService>((ref) {
  return MyService(
    ref.read(repositoryProvider),
    ref.read(otherServiceProvider),
  );
});

class MyService {
  final MyRepository _repository;
  final OtherService _otherService;
  
  MyService(this._repository, this._otherService);
  
  Future<Result> doBusinessLogic() async {
    // Validation, orchestration, business rules
    final data = await _repository.getData();
    return _otherService.process(data);
  }
}
```

### Breaking Circular Dependencies
When services depend on each other, add explicit types:

```dart
// Both providers need explicit types to break inference cycle
final Provider<ServiceA> serviceAProvider = Provider<ServiceA>((ref) {
  final ServiceB serviceB = ref.read(serviceBProvider);
  return ServiceA(serviceB);
});

final Provider<ServiceB> serviceBProvider = Provider<ServiceB>((ref) {
  final ServiceA serviceA = ref.read(serviceAProvider);
  return ServiceB(serviceA);
});
```

### Don't Create Thin Wrappers
❌ **Bad: Thin repository that just delegates**
```dart
class KeyRepository {
  final Ref _ref;
  Future<String?> getKey() => KeyService.getKey();
  Future<void> clearKey() {
    await KeyService.clearKey();
    _ref.invalidate(keyProvider);
  }
}
```

✅ **Good: Use service directly with providers**
```dart
final keyServiceProvider = Provider<KeyService>((ref) => KeyService());

final currentKeyProvider = FutureProvider<String?>((ref) async {
  final keyService = ref.watch(keyServiceProvider);
  return await keyService.getCurrentKey();
});
```

## Nostr Key Format Conventions

### Hex Format (Internal)
- **Use hex format (64 characters, no 0x prefix) for:**
  - All internal data storage and processing
  - Service-to-service communication
  - Database storage
  - API payloads
  - Cryptographic operations
  - Model fields (e.g., `KeyHolder.pubkey`, `ShardEvent.recipientPubkey`)

### Bech32 Format (UI/Display)
- **Use bech32 format (npub1..., nsec1...) for:**
  - User interface display
  - User input fields
  - Logging for human readability
  - Error messages shown to users
  - Configuration files that users edit

## Nostr Event Payload Conventions

### Snake Case for Raw Nostr Events
- **Always use snake_case (not camelCase) for JSON payloads in raw Nostr events**
  - NDK automatically converts snake_case to camelCase when processing events
  - This ensures consistency across the Nostr protocol
  - Examples: `lockbox_id`, `shard_index`, `invite_code`, `confirmed_at`

**Example:**
```dart
// ✅ Good: Use snake_case in Nostr event payloads
final confirmationData = {
  'type': 'shard_confirmation',
  'lockbox_id': lockboxId,
  'shard_index': shardIndex,
  'key_holder_pubkey': currentPubkey,
  'confirmed_at': DateTime.now().toIso8601String(),
};

// ❌ Bad: Don't use camelCase in Nostr event payloads
final confirmationData = {
  'lockboxId': lockboxId,  // Wrong - NDK expects snake_case
  'shardIndex': shardIndex,
};
```

## Nostr Event Expiration

### NIP-40 Expiration Tags
- **All Nostr events published by Keydex MUST include NIP-40 expiration tags**
- Expiration is set to 7 days from publication time
- Expiration tags are automatically added by `publishEncryptedEvent` and `publishEncryptedEventToMultiple`
- Format: `['expiration', '<unix_timestamp_in_seconds>']` per NIP-40 specification
- The expiration tag is added to the rumor event (inner event), not the gift wrap (outer event)
- See NIP-40 for full specification details

**Note:** When publishing events, you do NOT need to manually add expiration tags. They are automatically included by the publishing functions.